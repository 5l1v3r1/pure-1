%SORTS Prop | Type
%AXIOMS Prop : Type
%RULES Prop ~> Prop | Prop ~> Type | Type ~> Prop | Type ~> Type


let T : Prop 
= \/(A : Prop) A -> A

let <> : T 
= \(_ x) x

let id : T 
= <>

let F : Prop
= \/(A : Prop) A


let >>> : \/(A B C : Prop) (A -> B) -> (B -> C) -> A -> C 
        = \(_ _ _ f g x) g (f x) 


let & : Prop -> Prop -> Prop 
= \(A B) \/(C : Prop) (A -> B -> C) -> C

let pair : \/(A B : Prop) A -> B -> & A B
= \(_ _ x y)\(_ e) e x y

let fst : \/(A B : Prop) & A B -> A 
= \(A _ p) p A (\(x _) x)

let snd : \/(A B : Prop) & A B -> B
= \(_ B p) p B (\(_ y) y)


let + : Prop -> Prop -> Prop
= \(A B) \/(C : Prop) (A -> C) -> (B -> C) -> C

let inl : \/(A B : Prop) A -> + A B
= \(_ _ x)\(_ e _) e x

let inr : \/(A B : Prop) B -> + A B
= \(_ _ y)\(_ _ e) e y 

let case : \/(A B C : Prop) + A B -> (A -> C) -> (B -> C) -> C
= \(_ _ C s e1 e2) s C e1 e2


let curry : \/(A B C : Prop) (& A B -> C) -> A -> B -> C
= \(A B _ f x y) f (pair A B x y)

let uncurry : \/(A B C : Prop) (A -> B -> C) -> & A B -> C
= \(A B _ f p) f (fst A B p) (snd A B p)

let Refl : (\/(A : Prop) A -> A -> Prop) -> Prop 
= \(R) \/(A : Prop)(x : A) R A x x

let Sym : (\/(A : Prop) A -> A -> Prop) -> Prop  
= \(R) \/(A : Prop)(x y : A) R A x y -> R A y x

let Trans : (\/(A : Prop) A -> A -> Prop) -> Prop 
= \(R) \/(A : Prop)(x y z : A) R A x y -> R A y z -> R A x z


let Eq : \/(A : Prop) A -> A -> Prop
= \(A x y) \/(P : A -> Prop) P x -> P y

let eq-refl : Refl Eq
= \(A x)\(P) id (P x)

let eq-sym : Sym Eq 
= \(A x y eq)\(P) eq (\(z) P z -> P x) (eq-refl A x P)

let eq-trans : Trans Eq 
= \(A x y z eq1 eq2)\(P) >>> (P x) (P y) (P z) (eq1 P) (eq2 P)






